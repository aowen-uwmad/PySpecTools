<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2D2D2D" />
  
  <title>PySpecTools :: pyspectools.spectra.analysis</title>
  

  <link rel="icon" type="image/png" sizes="32x32" href="../../../_static/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../_static/img/favicon-16x16.png">
        <link rel="index" title="Index"
              href="../../../genindex.html"/>

  <link rel="stylesheet" href="../../../_static/css/insegel.css"/>

  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'',
        VERSION:'4.1.5',
        LANGUAGE:'None',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
    };
  </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>

  <script src="https://email.tl.fortawesome.com/c/eJxNjUEOgyAQAF8jR7Kw6wIHDh7sP1Cw2mgxgmn6-3JsMqc5zEQfE8dkxOY1KKMUOI3ACFKRJpSW2AAp7ontYIaxI6i7XPJVwyeVfCQ550Os3jLrGSNOLgbdAy6s0PBk2TFNjEbsfq31LB0OnX407pJa5v2faRadwSW63mn5KuLyR9j2tgx3zecanl-55R_-jjPs"></script>

</head>

<body>
  <div id="insegel-container">
    <header>
      <div id="logo-container">
          
          <a href="../../../index.html"><img src="../../../_static/img/logo.svg"></a>
          

      </div>
      <div id="project-container">
        <h1>PySpecTools Documentation</h1>
      </div>
    </header>

    <div id="content-container">

      <div id="main-content-container">
        <div id="main-content-header">
          <h1>pyspectools.spectra.analysis</h1>
        </div>
        <div id="main-content">
          
  <h1>Source code for pyspectools.spectra.analysis</h1><div class="highlight"><pre>
<span></span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">chain</span><span class="p">,</span> <span class="n">compress</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">peakutils</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="k">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span> <span class="nn">astroquery.splatalogue</span> <span class="k">import</span> <span class="n">Splatalogue</span>
<span class="kn">from</span> <span class="nn">lmfit</span> <span class="k">import</span> <span class="n">models</span><span class="p">,</span> <span class="n">MinimizerException</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="k">import</span> <span class="n">AffinityPropagation</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">silhouette_samples</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">windows</span>
<span class="kn">from</span> <span class="nn">uncertainties</span> <span class="k">import</span> <span class="n">ufloat</span>
<span class="kn">from</span> <span class="nn">bokeh.layouts</span> <span class="k">import</span> <span class="n">layout</span>
<span class="kn">from</span> <span class="nn">bokeh.io</span> <span class="k">import</span> <span class="n">save</span>
<span class="kn">from</span> <span class="nn">plotly</span> <span class="k">import</span> <span class="n">graph_objs</span> <span class="k">as</span> <span class="n">go</span>
<span class="kn">import</span> <span class="nn">numba</span>

<span class="kn">from</span> <span class="nn">pyspectools</span> <span class="k">import</span> <span class="n">fitting</span>
<span class="kn">from</span> <span class="nn">pyspectools</span> <span class="k">import</span> <span class="n">lineshapes</span>
<span class="kn">from</span> <span class="nn">pyspectools</span> <span class="k">import</span> <span class="n">routines</span>
<span class="kn">from</span> <span class="nn">pyspectools</span> <span class="k">import</span> <span class="n">ftmw_analysis</span> <span class="k">as</span> <span class="n">fa</span>
<span class="kn">from</span> <span class="nn">pyspectools.fast.routines</span> <span class="k">import</span> <span class="n">isin_array</span><span class="p">,</span> <span class="n">hot_match_arrays</span>
<span class="kn">from</span> <span class="nn">pyspectools</span> <span class="k">import</span> <span class="n">figurefactory</span>


<div class="viewcode-block" id="fit_line_profile"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.fit_line_profile">[docs]</a><span class="k">def</span> <span class="nf">fit_line_profile</span><span class="p">(</span><span class="n">spec_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">center</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                     <span class="n">intensity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_col</span><span class="o">=</span><span class="s2">&quot;Frequency&quot;</span><span class="p">,</span> <span class="n">int_col</span><span class="o">=</span><span class="s2">&quot;Intensity&quot;</span><span class="p">,</span>
                     <span class="n">fit_func</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">GaussianModel</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Somewhat high level function that wraps lmfit for</span>
<span class="sd">        fitting Gaussian lineshapes to a spectrum.</span>

<span class="sd">        For a given guess center and optional intensity,</span>
<span class="sd">        the </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">fit_func</span><span class="p">()</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">make_params</span><span class="p">()</span>
    <span class="c1"># Set up boundary conditions for the fit</span>
    <span class="n">params</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
        <span class="n">center</span><span class="p">,</span>
        <span class="nb">min</span><span class="o">=</span><span class="n">center</span> <span class="o">*</span> <span class="mf">0.9997</span><span class="p">,</span>
        <span class="nb">max</span><span class="o">=</span><span class="n">center</span> <span class="o">*</span> <span class="mf">1.0003</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Guess center: </span><span class="si">{:,.4f}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">center</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">intensity</span><span class="p">:</span>
        <span class="n">params</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
            <span class="n">intensity</span><span class="p">,</span>
            <span class="nb">min</span><span class="o">=</span><span class="mf">0.</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">width</span><span class="p">:</span>
        <span class="n">params</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
            <span class="n">width</span><span class="p">,</span>
            <span class="nb">min</span><span class="o">=</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.95</span><span class="p">,</span>
            <span class="nb">max</span><span class="o">=</span><span class="n">width</span> <span class="o">*</span> <span class="mf">1.05</span>
            <span class="p">)</span>
    <span class="c1"># Slice up a small chunk in frequency space; 0.5% of the</span>
    <span class="c1"># center frequency to allow for broad lineshapes</span>
    <span class="n">freq_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">center</span> <span class="o">*</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">0.9995</span><span class="p">,</span> <span class="mf">1.0005</span><span class="p">]]</span>
    <span class="n">slice_df</span> <span class="o">=</span> <span class="n">spec_df</span><span class="p">[</span>
        <span class="p">(</span><span class="n">spec_df</span><span class="p">[</span><span class="n">freq_col</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">freq_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spec_df</span><span class="p">[</span><span class="n">freq_col</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">freq_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">]</span>
    <span class="c1"># Fit the peak lineshape</span>
    <span class="n">fit_results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">slice_df</span><span class="p">[</span><span class="n">int_col</span><span class="p">],</span>
        <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
        <span class="n">x</span><span class="o">=</span><span class="n">slice_df</span><span class="p">[</span><span class="n">freq_col</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">fit_results</span><span class="o">.</span><span class="n">fit_report</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">fit_results</span><span class="o">.</span><span class="n">success</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fit_results</span><span class="o">.</span><span class="n">best_values</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">fit_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fit_results</span><span class="o">.</span><span class="n">best_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>
        <span class="c1"># Estimate standard error based on covariance matrix</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">fit_results</span><span class="o">.</span><span class="n">covar</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fit_values</span><span class="p">))</span>
        <span class="n">percentage</span> <span class="o">=</span> <span class="p">(</span><span class="n">variance</span> <span class="o">/</span> <span class="n">fit_values</span><span class="p">)</span> <span class="o">*</span> <span class="mf">100.</span>
        <span class="c1"># In the instance where standard errors are large, we need to work out confidence intervals explicitly</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">percentage</span><span class="p">[</span><span class="n">percentage</span> <span class="o">&gt;=</span> <span class="mf">5.</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If using a Gaussian line profile, we can do extra statistics</span>
            <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Large covariance detected; working out confidence intervals.&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ci</span> <span class="o">=</span> <span class="n">fit_results</span><span class="o">.</span><span class="n">conf_interval</span><span class="p">()</span>
                <span class="c1"># Get the index corresponding to the right amount of sigma. Indices run 0 - 3 for one side, giving</span>
                <span class="c1"># 3, 2, 1 and 0 sigma values</span>
                <span class="n">uncer</span> <span class="o">=</span> <span class="n">fit_values</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ci</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">sigma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">MinimizerException</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="c1"># Instances where changing a parameter does not affect the residuals at all; i.e. the cost function</span>
                <span class="c1"># is too flat w.r.t. to a parameter. In these cases we can&#39;t evaluate confidence intervals, and instead</span>
                <span class="c1"># we&#39;ll simply use the standard error of mean</span>
                <span class="k">if</span> <span class="n">logger</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Confidence intervals could not be evaluated, defaulting to standard error of mean.&quot;</span><span class="p">)</span>
                <span class="n">uncer</span> <span class="o">=</span> <span class="n">variance</span> <span class="o">*</span> <span class="n">sigma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise, use the standard error of the mean as the uncertainty, multiplied by</span>
            <span class="c1"># the number of &quot;sigma&quot;</span>
            <span class="n">uncer</span> <span class="o">=</span> <span class="n">variance</span> <span class="o">*</span> <span class="n">sigma</span>
        <span class="c1"># This bit is just formatting: format into a paired list then flatten</span>
        <span class="n">summary_dict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">ufloat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">uncertainty</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">uncertainty</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fit_values</span><span class="p">,</span> <span class="n">uncer</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">summary_dict</span><span class="p">[</span><span class="s2">&quot;Chi squared&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_results</span><span class="o">.</span><span class="n">chisqr</span>
        <span class="k">return</span> <span class="n">fit_results</span><span class="p">,</span> <span class="n">summary_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="peak_find"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.peak_find">[docs]</a><span class="k">def</span> <span class="nf">peak_find</span><span class="p">(</span><span class="n">spec_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">freq_col</span><span class="o">=</span><span class="s2">&quot;Frequency&quot;</span><span class="p">,</span> <span class="n">int_col</span><span class="o">=</span><span class="s2">&quot;Intensity&quot;</span><span class="p">,</span>
              <span class="n">thres</span><span class="o">=</span><span class="mf">0.015</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Wrapper for peakutils applied to pandas dataframes. First finds</span>
<span class="sd">        the peak indices, which are then used to fit Gaussians to determine</span>
<span class="sd">        the center frequency for each peak.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spec_df: dataframe</span>
<span class="sd">            Pandas dataframe containing the spectrum information, with columns corresponding to frequency and intensity.</span>
<span class="sd">        freq_col: str, optional</span>
<span class="sd">            Name of the frequency column in `spec_df`</span>
<span class="sd">        int_col: str, optional</span>
<span class="sd">            Name of the intensity column in `spec_df`</span>
<span class="sd">        thres: float, optional</span>
<span class="sd">            Threshold for peak detection</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        peak_df</span>
<span class="sd">            Pandas dataframe containing the peaks frequency/intensity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">peak_indices</span> <span class="o">=</span> <span class="n">peakutils</span><span class="o">.</span><span class="n">indexes</span><span class="p">(</span>
        <span class="n">spec_df</span><span class="p">[</span><span class="n">int_col</span><span class="p">],</span>
        <span class="n">thres</span><span class="o">=</span><span class="n">thres</span><span class="p">,</span>
        <span class="n">thres_abs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">min_dist</span><span class="o">=</span><span class="n">min_dist</span>
        <span class="p">)</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">peakutils</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">spec_df</span><span class="p">[</span><span class="n">freq_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">y</span><span class="o">=</span><span class="n">spec_df</span><span class="p">[</span><span class="n">int_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">ind</span><span class="o">=</span><span class="n">peak_indices</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">11</span>
        <span class="p">)</span>
    <span class="c1"># Get the peaks if we were just using indexes</span>
    <span class="n">direct_df</span> <span class="o">=</span> <span class="n">spec_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">peak_indices</span><span class="p">]</span>
    <span class="n">direct_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">direct_freqs</span> <span class="o">=</span> <span class="n">direct_df</span><span class="p">[</span><span class="n">freq_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="c1"># Calculate the difference in fit vs. approximate peak</span>
    <span class="c1"># frequencies</span>
    <span class="n">differences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">direct_df</span><span class="p">[</span><span class="n">freq_col</span><span class="p">]</span> <span class="o">-</span> <span class="n">frequencies</span><span class="p">)</span>
    <span class="n">intensities</span> <span class="o">=</span> <span class="n">spec_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">peak_indices</span><span class="p">][</span><span class="n">int_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">peak_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">direct_freqs</span><span class="p">,</span> <span class="n">intensities</span><span class="p">)),</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">,</span> <span class="s2">&quot;Peak Frequencies&quot;</span><span class="p">,</span> <span class="s2">&quot;Intensity&quot;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="c1"># Take the indexed frequencies if the fit exploded</span>
    <span class="c1"># and deviates significantly from the original prediction</span>
    <span class="n">peak_df</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="n">direct_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">differences</span> <span class="o">&gt;=</span> <span class="mf">0.2</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="c1"># Use 1sigma as the detection threshold; remove everything else!</span>
    <span class="n">peak_df</span> <span class="o">=</span> <span class="n">peak_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">peak_df</span><span class="p">[</span><span class="s2">&quot;Intensity&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">thres</span>
        <span class="p">]</span>
    <span class="n">peak_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">peak_df</span></div>


<div class="viewcode-block" id="search_molecule"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.search_molecule">[docs]</a><span class="k">def</span> <span class="nf">search_molecule</span><span class="p">(</span><span class="n">species</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">freq_range</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">40e3</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to search Splatalogue for a specific molecule. Technically I&#39;d prefer to</span>
<span class="sd">    download entries from CDMS instead, but this is probably the most straight</span>
<span class="sd">    forward way.</span>

<span class="sd">    The main use for this function is to verify line identifications - if a line is</span>
<span class="sd">    tentatively assigned to a U-line, then other transitions for the molecule that</span>
<span class="sd">    are stronger or comparatively strong should be visible.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    species: str</span>
<span class="sd">        Chemical name of the molecule</span>
<span class="sd">    freq_range: list</span>
<span class="sd">        The frequency range to perform the lookup</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DataFrame or None</span>
<span class="sd">        Pandas dataframe containing transitions for the given molecule. If no matches are found, returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">default_param</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;line_lists&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;CDMS&quot;</span><span class="p">,</span> <span class="s2">&quot;JPL&quot;</span><span class="p">],</span>
        <span class="s2">&quot;export_limit&quot;</span><span class="p">:</span> <span class="mi">20000</span>
    <span class="p">}</span>
    <span class="n">default_param</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">splat_df</span> <span class="o">=</span> <span class="n">Splatalogue</span><span class="o">.</span><span class="n">query_lines</span><span class="p">(</span>
        <span class="nb">min</span><span class="p">(</span><span class="n">freq_range</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">MHz</span><span class="p">,</span>
        <span class="nb">max</span><span class="p">(</span><span class="n">freq_range</span><span class="p">)</span> <span class="o">*</span> <span class="n">u</span><span class="o">.</span><span class="n">MHz</span><span class="p">,</span>
        <span class="n">chemical_name</span><span class="o">=</span><span class="n">species</span><span class="p">,</span>
        <span class="o">**</span><span class="n">default_param</span>
    <span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">splat_df</span><span class="p">)</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># These are the columns wanted</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;Species&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Chemical Name&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Meas Freq-GHz(rest frame,redshifted)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Freq-GHz(rest frame,redshifted)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Resolved QNs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;CDMS/JPL Intensity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;E_U (K)&quot;</span>
        <span class="p">]</span>
        <span class="c1"># Take only what we want</span>
        <span class="n">splat_df</span> <span class="o">=</span> <span class="n">splat_df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">splat_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;Species&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Chemical Name&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Meas Freq-GHz&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Freq-GHz&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Resolved QNs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;CDMS/JPL Intensity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;E_U (K)&quot;</span>
        <span class="p">]</span>
        <span class="c1"># Now we combine the frequency measurements</span>
        <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Meas Freq-GHz&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># Replace missing experimental data with calculated</span>
        <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Freq-GHz&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Convert to MHz</span>
        <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1000.</span>
        <span class="k">return</span> <span class="n">splat_df</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="search_center_frequency"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.search_center_frequency">[docs]</a><span class="k">def</span> <span class="nf">search_center_frequency</span><span class="p">(</span><span class="n">frequency</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function for wrapping the astroquery Splatalogue API for looking up a frequency and finding candidate molecules</span>
<span class="sd">    for assignment. The width parameter adjusts the +/- range to include in the search: for high frequency surveys,</span>
<span class="sd">    it&#39;s probably preferable to use a percentage to accommodate for the typically larger uncertainties (sub-mm</span>
<span class="sd">    experiments).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequency: float</span>
<span class="sd">        Frequency in MHz to search Splatalogue for.</span>
<span class="sd">    width: float, optional</span>
<span class="sd">        Absolute frequency offset in MHz to include in the search.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dataframe or None</span>
<span class="sd">        Pandas dataframe containing frequency matches, or None if no matches are found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_freq</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">-</span> <span class="n">width</span>
    <span class="n">max_freq</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">+</span> <span class="n">width</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">splat_df</span> <span class="o">=</span> <span class="n">Splatalogue</span><span class="o">.</span><span class="n">query_lines</span><span class="p">(</span>
            <span class="n">min_freq</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">MHz</span><span class="p">,</span>
            <span class="n">max_freq</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">MHz</span><span class="p">,</span>
            <span class="n">line_lists</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CDMS&quot;</span><span class="p">,</span> <span class="s2">&quot;JPL&quot;</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
        <span class="c1"># These are the columns wanted</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;Species&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Chemical Name&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Meas Freq-GHz(rest frame,redshifted)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Freq-GHz(rest frame,redshifted)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Resolved QNs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;CDMS/JPL Intensity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;E_U (K)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;E_L (K)&quot;</span>
            <span class="p">]</span>
        <span class="c1"># Take only what we want</span>
        <span class="n">splat_df</span> <span class="o">=</span> <span class="n">splat_df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">splat_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;Species&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Chemical Name&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Meas Freq-GHz&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Freq-GHz&quot;</span><span class="p">,</span>
            <span class="s2">&quot;Resolved QNs&quot;</span><span class="p">,</span>
            <span class="s2">&quot;CDMS/JPL Intensity&quot;</span><span class="p">,</span>
            <span class="s2">&quot;E_U (K)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;E_L (K)&quot;</span>
            <span class="p">]</span>
        <span class="c1"># Now we combine the frequency measurements</span>
        <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Meas Freq-GHz&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="c1"># Replace missing experimental data with calculated</span>
        <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Freq-GHz&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Convert to MHz</span>
        <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1000.</span>
        <span class="k">return</span> <span class="n">splat_df</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Could not parse Splatalogue table at </span><span class="si">{:,.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">frequency</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="calc_line_weighting"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.calc_line_weighting">[docs]</a><span class="k">def</span> <span class="nf">calc_line_weighting</span><span class="p">(</span>
        <span class="n">frequency</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">catalog_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">prox</span><span class="o">=</span><span class="mf">0.00005</span><span class="p">,</span>
        <span class="nb">abs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">freq_col</span><span class="o">=</span><span class="s2">&quot;Frequency&quot;</span><span class="p">,</span> <span class="n">int_col</span><span class="o">=</span><span class="s2">&quot;Intensity&quot;</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function for calculating the weighting factor for determining</span>
<span class="sd">        the likely hood of an assignment. The weighting factor is</span>
<span class="sd">        determined by the proximity of the catalog frequency to the</span>
<span class="sd">        observed frequency, as well as the theoretical intensity if it</span>
<span class="sd">        is available.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">         frequency : float</span>
<span class="sd">            Observed frequency in MHz</span>
<span class="sd">         catalog_df : dataframe</span>
<span class="sd">            Pandas dataframe containing the catalog data entries</span>
<span class="sd">         prox: float, optional</span>
<span class="sd">            Frequency proximity threshold</span>
<span class="sd">         abs: bool</span>
<span class="sd">            Specifies whether argument prox is taken as the absolute value</span>
<span class="sd">        Returns</span>
<span class="sd">        ---------------</span>
<span class="sd">        None</span>
<span class="sd">            If nothing matches the frequency, returns None.</span>
<span class="sd">        dataframe</span>
<span class="sd">            If matches are found, calculate the weights and return the</span>
<span class="sd">            candidates in a dataframe.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">abs</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">lower_freq</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">prox</span><span class="p">)</span>
        <span class="n">upper_freq</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">prox</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lower_freq</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">-</span> <span class="n">prox</span>
        <span class="n">upper_freq</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">+</span> <span class="n">prox</span>
    <span class="n">sliced_catalog</span> <span class="o">=</span> <span class="n">catalog_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span>
        <span class="n">catalog_df</span><span class="p">[</span><span class="n">freq_col</span><span class="p">]</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">lower_freq</span><span class="p">,</span> <span class="n">upper_freq</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">nentries</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sliced_catalog</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nentries</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">int_col</span> <span class="ow">in</span> <span class="n">sliced_catalog</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">sliced_catalog</span><span class="p">[</span><span class="n">int_col</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;CDMS/JPL Intensity&quot;</span> <span class="ow">in</span> <span class="n">sliced_catalog</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">sliced_catalog</span><span class="p">[</span><span class="s2">&quot;CDMS/JPL Intensity&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">column</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Vectorized function for calculating the line weighting</span>
        <span class="n">sliced_catalog</span><span class="p">[</span><span class="s2">&quot;Weighting&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_weighting</span><span class="p">(</span>
            <span class="n">frequency</span><span class="p">,</span> <span class="n">sliced_catalog</span><span class="p">[</span><span class="n">freq_col</span><span class="p">],</span> <span class="n">column</span>
        <span class="p">)</span>
        <span class="c1"># Normalize and sort the weights only if there are more than one</span>
        <span class="c1"># candidates</span>
        <span class="k">if</span> <span class="n">nentries</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sliced_catalog</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s2">&quot;Weighting&quot;</span><span class="p">]</span> <span class="o">/=</span> <span class="n">sliced_catalog</span><span class="p">[</span>
                <span class="s2">&quot;Weighting&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="c1"># Sort by obs-calc</span>
            <span class="n">sliced_catalog</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;Weighting&quot;</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">sliced_catalog</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sliced_catalog</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="brute_harmonic_search"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.brute_harmonic_search">[docs]</a><span class="k">def</span> <span class="nf">brute_harmonic_search</span><span class="p">(</span><span class="n">frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">maxJ</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dev_thres</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">prefilter</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that will search for possible harmonic candidates</span>
<span class="sd">        in a list of frequencies. Wraps the lower level function.</span>

<span class="sd">        Generates every possible 4 membered combination of the</span>
<span class="sd">        frequencies, and makes a first pass filtering out unreasonable</span>
<span class="sd">        combinations.</span>

<span class="sd">        parameters:</span>
<span class="sd">        ----------------</span>
<span class="sd">        frequencies - iterable containing floats of frequencies (ulines)</span>
<span class="sd">        maxJ - maximum value of J considered for quantum numbers</span>
<span class="sd">        dev_thres - standard deviation threshold for filtering unlikely</span>
<span class="sd">                    combinations of frequencies</span>
<span class="sd">        prefilter - bool dictating whether or not the frequency lists</span>
<span class="sd">                    are prescreened by standard deviation. This potentially</span>
<span class="sd">                    biases away from missing transitions!</span>

<span class="sd">        returns:</span>
<span class="sd">        ----------------</span>
<span class="sd">        results_df - pandas dataframe containing RMS information and fitted</span>
<span class="sd">                     constants</span>
<span class="sd">        fit_results - list containing all of ModelResult objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
    <span class="c1"># List for holding candidates</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Generating possible frequency combinations.&quot;</span><span class="p">)</span>
    <span class="c1"># Sweep through all possible combinations, and look</span>
    <span class="c1"># for viable candidates</span>
    <span class="k">if</span> <span class="n">prefilter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]:</span>
            <span class="c1"># Check the length of array we need...</span>
            <span class="c1">#if comb(len(frequencies), length) &gt; 5e6:</span>
            <span class="c1">#    pass</span>
            <span class="n">combos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">length</span><span class="p">)))</span>
            <span class="c1"># Calculate the standard deviation between frequency</span>
            <span class="c1"># entries - if the series is harmonic, then the deviation</span>
            <span class="c1"># should be low and only due to CD terms</span>
            <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">combos</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">combos</span> <span class="o">=</span> <span class="n">combos</span><span class="p">[</span><span class="n">deviation</span> <span class="o">&lt;</span> <span class="mf">100.</span><span class="p">]</span>
            <span class="n">deviation</span> <span class="o">=</span> <span class="n">deviation</span><span class="p">[</span><span class="n">deviation</span> <span class="o">&lt;</span> <span class="mf">100.</span><span class="p">]</span>
            <span class="n">sorted_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">deviation</span><span class="p">)[:</span><span class="mi">50</span><span class="p">]</span>
            <span class="n">sorted_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">deviation</span><span class="p">)[:</span><span class="mi">50</span><span class="p">]</span>
            <span class="n">candidates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">combos</span><span class="p">[</span><span class="n">sorted_indexes</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of candidates: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">prefilter</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># If we won&#39;t prefilter, then just chain the</span>
        <span class="c1"># generators together</span>
        <span class="c1"># THIS WILL BE FREAKING SLOW</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span>
            <span class="n">combinations</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">combinations</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
            <span class="n">combinations</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">data_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">fit_results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">prefilter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.50</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">])</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">progress</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span> <span class="k">for</span> <span class="n">prog</span> <span class="ow">in</span> <span class="n">progress</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Looping over candidate combinations&quot;</span><span class="p">)</span>
    <span class="c1"># Perform the fitting procedure on candidate combinations</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
        <span class="c1"># Only fit the ones that </span>
        <span class="n">min_rms</span><span class="p">,</span> <span class="n">min_index</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">fit_values</span><span class="p">,</span> <span class="n">fit_objs</span> <span class="o">=</span> <span class="n">fitting</span><span class="o">.</span><span class="n">harmonic_fit</span><span class="p">(</span>
            <span class="n">candidate</span><span class="p">,</span> 
            <span class="n">maxJ</span><span class="o">=</span><span class="n">maxJ</span><span class="p">,</span> 
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span><span class="n">index</span><span class="p">,</span> 
             <span class="n">min_rms</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="p">),</span> 
             <span class="n">candidate</span><span class="p">,</span>
             <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">fit_values</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>
            <span class="p">)</span>
        <span class="n">fit_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_objs</span><span class="p">[</span><span class="n">min_index</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">prefilter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">progress</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> candidates screened.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finalizing results.&quot;</span><span class="p">)</span>
    <span class="n">results_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">data_list</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="s2">&quot;RMS&quot;</span><span class="p">,</span> <span class="s2">&quot;Frequencies&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="n">results_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;RMS&quot;</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">results_df</span><span class="p">,</span> <span class="n">fit_results</span></div>


<div class="viewcode-block" id="harmonic_finder"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.harmonic_finder">[docs]</a><span class="k">def</span> <span class="nf">harmonic_finder</span><span class="p">(</span><span class="n">frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">low_B</span><span class="o">=</span><span class="mf">400.</span><span class="p">,</span> <span class="n">high_B</span><span class="o">=</span><span class="mf">9000.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that will generate candidates for progressions.</span>
<span class="sd">        Every possible pair combination of frequencies are</span>
<span class="sd">        looped over, consider whether or not the B value is either</span>
<span class="sd">        too small (like C60 large) or too large (you won&#39;t have</span>
<span class="sd">        enough lines to make a progression), and search the</span>
<span class="sd">        frequencies to find the nearest candidates based on a</span>
<span class="sd">        prediction.</span>
<span class="sd">        </span>
<span class="sd">        parameters:</span>
<span class="sd">        ----------------</span>
<span class="sd">        frequencies - array or tuple-like containing the progressions</span>
<span class="sd">                      we expect to find</span>
<span class="sd">        search - optional argument threshold for determining if something</span>
<span class="sd">                 is close enough</span>
<span class="sd">                 </span>
<span class="sd">        returns:</span>
<span class="sd">        ----------------</span>
<span class="sd">        progressions - list of arrays corresponding to candidate progressions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
    <span class="n">progressions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="c1"># Ignore everything that is too large or too small</span>
        <span class="n">guess_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">low_B</span> <span class="o">&lt;=</span> <span class="n">guess_B</span> <span class="o">&lt;=</span> <span class="n">high_B</span><span class="p">:</span>
            <span class="n">combo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span>
            <span class="c1"># From B, determine the next series of lines and</span>
            <span class="c1"># find the closest ones</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">find_series</span><span class="p">(</span><span class="n">combo</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">search</span><span class="p">)</span>          
            <span class="n">progressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">progressions</span></div>


<div class="viewcode-block" id="cluster_AP_analysis"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.cluster_AP_analysis">[docs]</a><span class="k">def</span> <span class="nf">cluster_AP_analysis</span><span class="p">(</span><span class="n">progression_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">sil_calc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for the AffinityPropagation cluster method from</span>
<span class="sd">        scikit-learn.</span>

<span class="sd">        The dataframe provided will also receive new columns: Cluster index,</span>
<span class="sd">        and Silhouette. The latter corresponds to how likely a sample is</span>
<span class="sd">        sandwiched between clusters (0), how squarely it belongs in the</span>
<span class="sd">        assigned cluster (+1), or does not belong (-1). The cluster index</span>
<span class="sd">        corresponds to which cluster the sample belongs to.</span>

<span class="sd">        parameters:</span>
<span class="sd">        ---------------</span>
<span class="sd">        progression_df - pandas dataframe taken from the result of progression</span>
<span class="sd">                         fits</span>
<span class="sd">        sil_calc - bool indicating whether silhouettes are calculated</span>
<span class="sd">                   after the AP model is fit</span>
<span class="sd">        </span>
<span class="sd">        returns:</span>
<span class="sd">        --------------</span>
<span class="sd">        data - dict containing clustered frequencies and associated fits</span>
<span class="sd">        ap_obj - AffinityPropagation object containing all the information</span>
<span class="sd">                 as attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ap_options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">ap_options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">ap_obj</span> <span class="o">=</span> <span class="n">AffinityPropagation</span><span class="p">(</span><span class="o">**</span><span class="n">ap_options</span><span class="p">)</span>
    <span class="c1"># Determine clusters based on the RMS, B, and D similarities</span>
    <span class="c1"># Remove occurrences of NaN in the three columns</span>
    <span class="n">progression_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;RMS&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Fit a random 40% subset of the B, D, results to the cluster model</span>
    <span class="n">ap_obj</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">progression_df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)[[</span><span class="s2">&quot;RMS&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]])</span>
    <span class="c1"># Predict the clusters</span>
    <span class="n">progression_df</span><span class="p">[</span><span class="s2">&quot;Cluster indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ap_obj</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span>
        <span class="n">progression_df</span><span class="p">[[</span><span class="s2">&quot;RMS&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]]</span>
    <span class="p">)</span>
    <span class="c1"># Indicate which progression fits with which cluster</span>
    <span class="c1">#progression_df[&quot;Cluster indices&quot;] = ap_obj.labels_</span>
    <span class="c1"># Calculate the metric for determining how well a sample</span>
    <span class="c1"># fits into its cluster</span>
    <span class="k">if</span> <span class="n">sil_calc</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">progression_df</span><span class="p">[</span><span class="s2">&quot;Silhouette&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">silhouette_samples</span><span class="p">(</span>
            <span class="n">progression_df</span><span class="p">[[</span><span class="s2">&quot;RMS&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]],</span>
            <span class="n">progression_df</span><span class="p">[</span><span class="s2">&quot;Cluster indices&quot;</span><span class="p">],</span>
            <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span>
        <span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="c1"># Loop over each cluster, and aggregate the frequencies together</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">progression_df</span><span class="p">[</span><span class="s2">&quot;Cluster indices&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()):</span>
        <span class="n">data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">ap_obj</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">slice_df</span> <span class="o">=</span> <span class="n">progression_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">progression_df</span><span class="p">[</span><span class="s2">&quot;Cluster indices&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">]</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">progression_df</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">unique_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">slice_df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">unique_frequencies</span> <span class="o">=</span> <span class="n">unique_frequencies</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unique_frequencies</span><span class="p">)]</span>
        <span class="n">data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s2">&quot;Frequencies&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_frequencies</span>
        <span class="k">if</span> <span class="n">refit</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Refit the whole list of frequencies with B and D again</span>
            <span class="n">BJ_model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">fitting</span><span class="o">.</span><span class="n">calc_harmonic_transition</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">BJ_model</span><span class="o">.</span><span class="n">make_params</span><span class="p">()</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="n">cluster_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="nb">min</span><span class="o">=</span><span class="n">cluster_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">0.99</span><span class="p">,</span>
                <span class="nb">max</span><span class="o">=</span><span class="n">cluster_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1.01</span>
                <span class="p">)</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;D&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Get values of J based on B again</span>
            <span class="n">J</span> <span class="o">=</span> <span class="p">(</span><span class="n">unique_frequencies</span> <span class="o">/</span> <span class="n">cluster_data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">BJ_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">unique_frequencies</span><span class="p">,</span>
                <span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span>
            <span class="p">)</span>
            <span class="c1"># Package results together</span>
            <span class="n">data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">best_values</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s2">&quot;oldRMS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="n">label</span><span class="p">][</span><span class="s2">&quot;RMS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">residual</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Reuse old RMS</span>
            <span class="n">fit_values</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">cluster_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="n">cluster_data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="s2">&quot;RMS&quot;</span><span class="p">:</span> <span class="n">cluster_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">}</span>
            <span class="n">data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fit_values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">progression_df</span><span class="p">,</span> <span class="n">ap_obj</span></div>


<div class="viewcode-block" id="find_series"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.find_series">[docs]</a><span class="k">def</span> <span class="nf">find_series</span><span class="p">(</span><span class="n">combo</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="mf">0.005</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that will exhaustively search for candidate</span>
<span class="sd">        progressions based on a pair of frequencies.</span>
<span class="sd">        </span>
<span class="sd">        The difference of the pair is used to estimate B,</span>
<span class="sd">        which is then used to calculate J. These values of</span>
<span class="sd">        J are then used to predict the next set of lines,</span>
<span class="sd">        which are searched for in the soup of frequencies.</span>
<span class="sd">        The closest matches are added to a list which is returned.</span>

<span class="sd">        This is done so that even if frequencies are missing</span>
<span class="sd">        a series of lines can still be considered.</span>

<span class="sd">        parameters:</span>
<span class="sd">        ---------------</span>
<span class="sd">        combo - pair of frequencies corresponding to initial guess</span>
<span class="sd">        frequencies - array of frequencies to be searched</span>
<span class="sd">        search - optional threshold for determining the search range</span>
<span class="sd">                 to look for candidates</span>

<span class="sd">        returns:</span>
<span class="sd">        --------------</span>
<span class="sd">        array of candidate frequencies</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lowest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span>
    <span class="n">approx_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">combo</span><span class="p">))</span>
    <span class="n">minJ</span> <span class="o">=</span> <span class="p">(</span><span class="n">lowest</span> <span class="o">/</span> <span class="n">approx_B</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minJ</span><span class="p">,</span> <span class="n">minJ</span> <span class="o">+</span> <span class="mf">20.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="c1"># Guess where all the next frequencies are</span>
    <span class="n">guess_centers</span> <span class="o">=</span> <span class="n">J</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">approx_B</span>
    <span class="c1"># Make sure it&#39;s within the band of trial frequencies</span>
    <span class="n">guess_centers</span> <span class="o">=</span> <span class="n">guess_centers</span><span class="p">[</span><span class="n">guess_centers</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)]</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">guess</span> <span class="ow">in</span> <span class="n">guess_centers</span><span class="p">:</span>
        <span class="n">lower_guess</span> <span class="o">=</span> <span class="n">guess</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">search</span><span class="p">)</span>
        <span class="n">upper_guess</span> <span class="o">=</span> <span class="n">guess</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">search</span><span class="p">)</span>
        <span class="n">nearest_neighbours</span> <span class="o">=</span> <span class="n">frequencies</span><span class="p">[</span>
            <span class="p">(</span><span class="n">frequencies</span> <span class="o">&gt;=</span> <span class="n">lower_guess</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">frequencies</span> <span class="o">&lt;=</span> <span class="n">upper_guess</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="c1"># If we don&#39;t find anything close enough, don&#39;t worry about it</span>
        <span class="c1"># this will make sure that missing lines aren&#39;t necessarily ignored</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nearest_neighbours</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Return the closest value to the predicted center</span>
            <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">nearest_neighbours</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">guess</span> <span class="o">-</span> <span class="n">nearest_neighbours</span><span class="p">))</span>
                <span class="p">]</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">candidates</span></div>


<div class="viewcode-block" id="create_cluster_tests"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.create_cluster_tests">[docs]</a><span class="k">def</span> <span class="nf">create_cluster_tests</span><span class="p">(</span><span class="n">cluster_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">shots</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> 
                         <span class="n">dipole</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mf">500.</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take the output of the cluster AP analysis, and generate the FTB batch</span>
<span class="sd">    files for a targeted DR search.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cluster_dict: dict</span>
<span class="sd">        Cluster dictionary with keys corresponding to the cluster number,</span>
<span class="sd">        and values are subdictionaries holding the frequencies associated</span>
<span class="sd">        with the cluster.</span>
<span class="sd">    shots: int, optional</span>
<span class="sd">        Number of integration counts</span>
<span class="sd">    dipole: float, optional</span>
<span class="sd">        Approximate dipole moment to target</span>
<span class="sd">    min_dist: float, optional</span>
<span class="sd">        Minimum frequency difference between the cavity and DR frequencies.</span>
<span class="sd">    kwargs</span>
<span class="sd">        Additional kwargs are passed to the ftb line generation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># In the event one wants to perform all of the clusters in a sitting</span>
    <span class="n">full_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="c1"># Loop over each cluster, and we&#39;ll generate an FTB file for that cluster</span>
    <span class="k">for</span> <span class="n">cluster</span><span class="p">,</span> <span class="n">subdict</span> <span class="ow">in</span> <span class="n">cluster_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">filepath</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;ftb/cluster</span><span class="si">{cluster}</span><span class="s2">-dr.ftb&quot;</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="n">subdict</span><span class="p">[</span><span class="s2">&quot;Frequencies&quot;</span><span class="p">]</span>
        <span class="n">ftb_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">ftb_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dipole&quot;</span><span class="p">:</span> <span class="n">dipole</span><span class="p">}</span>
        <span class="n">ftb_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cavity_freq</span> <span class="ow">in</span> <span class="n">frequencies</span><span class="p">:</span>
            <span class="c1"># First time a cavity frequency is used, tune there and turn</span>
            <span class="c1"># the DR off</span>
            <span class="n">ftb_dict</span><span class="p">[</span><span class="s2">&quot;drpower&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">20</span>
            <span class="n">ftb_str</span> <span class="o">+=</span> <span class="n">fa</span><span class="o">.</span><span class="n">generate_ftb_line</span><span class="p">(</span>
                <span class="n">cavity_freq</span><span class="p">,</span>
                <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">,</span>
                <span class="o">**</span><span class="n">ftb_dict</span>
            <span class="p">)</span>
            <span class="c1"># Loop over the other frequencies</span>
            <span class="k">for</span> <span class="n">dr_freq</span> <span class="ow">in</span> <span class="n">frequencies</span><span class="p">:</span>
                <span class="c1"># If we&#39;re sufficiently far away, then ping that transition</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cavity_freq</span> <span class="o">-</span> <span class="n">dr_freq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">min_dist</span><span class="p">:</span>
                    <span class="n">ftb_dict</span><span class="p">[</span><span class="s2">&quot;drpower&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">13</span>
                    <span class="n">ftb_dict</span><span class="p">[</span><span class="s2">&quot;drfreq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dr_freq</span><span class="p">)</span>
                    <span class="n">ftb_dict</span><span class="p">[</span><span class="s2">&quot;skiptune&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">ftb_str</span> <span class="o">+=</span> <span class="n">fa</span><span class="o">.</span><span class="n">generate_ftb_line</span><span class="p">(</span>
                        <span class="n">cavity_freq</span><span class="p">,</span>
                        <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">ftb_dict</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="n">full_str</span> <span class="o">+=</span> <span class="n">ftb_str</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;w+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">write_file</span><span class="p">:</span>
            <span class="n">write_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ftb_str</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;ftb/full-cluster-dr.ftb&quot;</span><span class="p">,</span> <span class="s2">&quot;w+&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">write_file</span><span class="p">:</span>
            <span class="n">write_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">full_str</span><span class="p">)</span></div>


<div class="viewcode-block" id="blank_spectrum"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.blank_spectrum">[docs]</a><span class="k">def</span> <span class="nf">blank_spectrum</span><span class="p">(</span>
        <span class="n">spectrum_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> 
        <span class="n">noise</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noise_std</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq_col</span><span class="o">=</span><span class="s2">&quot;Frequency&quot;</span><span class="p">,</span>
        <span class="n">int_col</span><span class="o">=</span><span class="s2">&quot;Intensity&quot;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to blank the peaks from a spectrum. Takes a iterable of frequencies, and generates an array of Gaussian</span>
<span class="sd">    noise corresponding to the average noise floor and standard deviation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    spectrum_df - pandas DataFrame</span>
<span class="sd">        Pandas DataFrame containing the spectral data</span>
<span class="sd">    frequencies - iterable of floats</span>
<span class="sd">        An iterable containing the center frequencies to blank</span>
<span class="sd">    noise - float</span>
<span class="sd">        Average noise value for the spectrum. Typically measured by choosing a region void of spectral lines.</span>
<span class="sd">    noise_std - float</span>
<span class="sd">        Standard deviation for the spectrum noise.</span>
<span class="sd">    freq_col - str</span>
<span class="sd">        Name of the column in spectrum_df to use for the frequency axis</span>
<span class="sd">    int_col - str</span>
<span class="sd">        Name of the column in spectrum_df to use for the intensity axis</span>
<span class="sd">    window - float</span>
<span class="sd">        Value to use for the range to blank. This region blanked corresponds to frequency+/-window.</span>
<span class="sd">    df - bool</span>
<span class="sd">        If True, returns a copy of the Pandas Dataframe with the blanked intensity.</span>
<span class="sd">        If False, returns a numpy 1D array corresponding to the blanked intensity.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_spec - pandas DataFrame or numpy 1D array</span>
<span class="sd">        If df is True, Pandas DataFrame with the intensity regions blanked.</span>
<span class="sd">        If df is False, numpy 1D array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_spec</span> <span class="o">=</span> <span class="n">spectrum_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># Reset the random number generator seed</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">frequencies</span><span class="p">:</span>
        <span class="c1"># Work out the length of the noise window we have to create</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">new_spec</span><span class="p">[</span><span class="n">freq_col</span><span class="p">]</span><span class="o">.</span><span class="n">between</span><span class="p">(</span>
            <span class="n">frequency</span> <span class="o">-</span> <span class="n">window</span><span class="p">,</span>
            <span class="n">frequency</span> <span class="o">+</span> <span class="n">window</span>
        <span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_spec</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span>
        <span class="c1"># Create Gaussian noise for this region</span>
        <span class="n">noise_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">noise_std</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
        <span class="n">new_spec</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">int_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise_array</span>
    <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_spec</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_spec</span><span class="p">[</span><span class="n">int_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span></div>


<div class="viewcode-block" id="plotly_create_experiment_comparison"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.plotly_create_experiment_comparison">[docs]</a><span class="k">def</span> <span class="nf">plotly_create_experiment_comparison</span><span class="p">(</span><span class="n">experiments</span><span class="p">,</span> <span class="n">thres_prox</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                       <span class="n">filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to create a plot comparing multiple experiments. This is a high</span>
<span class="sd">    level function that wraps the `correlate_experiments` function,</span>
<span class="sd">    and provides a visual and interactive view of the spectra output from</span>
<span class="sd">    this function using Plotly.</span>

<span class="sd">    This function is effectively equivalent to</span>
<span class="sd">    `bokeh_create_experiment_comparison`, however uses Plotly as the front</span>
<span class="sd">    end instead.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    experiments</span>
<span class="sd">    thres_prox</span>
<span class="sd">    index</span>
<span class="sd">    filepath</span>
<span class="sd">    kwargs</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">figurefactory</span><span class="o">.</span><span class="n">init_plotly_subplot</span><span class="p">(</span>
        <span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="s2">&quot;subplot_titles&quot;</span><span class="p">:</span>   <span class="p">[</span><span class="s2">&quot;Experiment Comparison&quot;</span><span class="p">,</span> <span class="s2">&quot;Unique Spectrum&quot;</span><span class="p">],</span>
            <span class="s2">&quot;vertical_spacing&quot;</span><span class="p">:</span> <span class="mf">0.15</span><span class="p">,</span>
            <span class="s2">&quot;shared_xaxes&quot;</span><span class="p">:</span>     <span class="kc">True</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="n">n_experiments</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">experiments</span><span class="p">)</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">figurefactory</span><span class="o">.</span><span class="n">generate_colors</span><span class="p">(</span>
        <span class="n">n_experiments</span><span class="p">,</span>
        <span class="s2">&quot;Set1&quot;</span><span class="p">,</span>
        <span class="nb">hex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">base_exp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">experiments</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
    <span class="n">top_traces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">top_traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scattergl</span><span class="p">(</span>
            <span class="n">x</span><span class="o">=</span><span class="n">base_exp</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">base_exp</span><span class="o">.</span><span class="n">freq_col</span><span class="p">],</span>
            <span class="n">y</span><span class="o">=</span><span class="n">base_exp</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">base_exp</span><span class="o">.</span><span class="n">int_col</span><span class="p">]</span> <span class="o">/</span> <span class="n">base_exp</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">baseline</span><span class="p">,</span>
            <span class="n">opacity</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
            <span class="n">line</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="n">colors</span><span class="p">[</span><span class="n">index</span><span class="p">]},</span>
            <span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="s2">&quot;Ref; </span><span class="si">{base_exp.session.experiment}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># Loop over all the experiments and plot them up</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">experiment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">experiments</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">top_traces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scattergl</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">=</span><span class="n">experiment</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">experiment</span><span class="o">.</span><span class="n">freq_col</span><span class="p">],</span>
                    <span class="n">y</span><span class="o">=</span><span class="n">experiment</span><span class="o">.</span><span class="n">data</span><span class="p">[</span>
                        <span class="n">experiment</span><span class="o">.</span><span class="n">int_col</span><span class="p">]</span> <span class="o">/</span> <span class="n">experiment</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">baseline</span><span class="p">,</span>
                    <span class="n">opacity</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                    <span class="n">line</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="n">colors</span><span class="p">[</span><span class="n">idx</span><span class="p">]},</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{experiment.session.experiment}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">add_traces</span><span class="p">(</span><span class="n">top_traces</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">experiments</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">experiments</span><span class="p">))</span>
    <span class="n">base</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">correlate_experiments</span><span class="p">(</span>
        <span class="n">experiments</span><span class="p">,</span> <span class="n">thres_prox</span><span class="o">=</span><span class="n">thres_prox</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span>
    <span class="p">)</span>
    <span class="n">bottom_trace</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Scattergl</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">],</span>
        <span class="n">y</span><span class="o">=</span><span class="n">base</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Unique Spectrum&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">base</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">baseline</span><span class="p">,</span>
        <span class="n">opacity</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
        <span class="n">line</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;color&quot;</span><span class="p">:</span> <span class="n">colors</span><span class="p">[</span><span class="n">index</span><span class="p">]},</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Unique Spectrum&quot;</span>
    <span class="p">)</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">add_traces</span><span class="p">([</span><span class="n">bottom_trace</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">fig</span><span class="p">[</span><span class="s2">&quot;layout&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="n">autosize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">height</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">900</span><span class="p">,</span>
        <span class="n">showlegend</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">fig</span><span class="p">[</span><span class="s2">&quot;layout&quot;</span><span class="p">][</span><span class="s2">&quot;xaxis1&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Frequency (MHz)&quot;</span><span class="p">,</span>
        <span class="n">showgrid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">tickformat</span><span class="o">=</span><span class="s2">&quot;:.0f&quot;</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;yaxis1&quot;</span><span class="p">,</span> <span class="s2">&quot;yaxis2&quot;</span><span class="p">]:</span>
        <span class="n">fig</span><span class="p">[</span><span class="s2">&quot;layout&quot;</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Signal-to-Noise&quot;</span><span class="p">,</span>
            <span class="n">showgrid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">tickformat</span><span class="o">=</span><span class="s2">&quot;:.0f&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span></div>


<div class="viewcode-block" id="bokeh_create_experiment_comparison"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.bokeh_create_experiment_comparison">[docs]</a><span class="k">def</span> <span class="nf">bokeh_create_experiment_comparison</span><span class="p">(</span><span class="n">experiments</span><span class="p">,</span> <span class="n">thres_prox</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                 <span class="n">filepath</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to create a plot comparing multiple experiments. This is a high</span>
<span class="sd">    level function that wraps the `correlate_experiments` function,</span>
<span class="sd">    and provides a visual and interactive view of the spectra output from</span>
<span class="sd">    this function using Bokeh.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    experiments</span>
<span class="sd">    thres_prox</span>
<span class="sd">    index</span>
<span class="sd">    filepath</span>
<span class="sd">    kwargs</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;plot_height&quot;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
        <span class="s2">&quot;plot_width&quot;</span><span class="p">:</span> <span class="mi">900</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Experiment Comparison&quot;</span>
    <span class="p">}</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">full_fig</span> <span class="o">=</span> <span class="n">figurefactory</span><span class="o">.</span><span class="n">init_bokeh_figure</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">full_fig</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="s2">&quot;Signal-to-noise&quot;</span>
    <span class="n">n_experiments</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">experiments</span><span class="p">)</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">figurefactory</span><span class="o">.</span><span class="n">generate_colors</span><span class="p">(</span>
        <span class="n">n_experiments</span><span class="p">,</span>
        <span class="s2">&quot;Pastel1&quot;</span><span class="p">,</span>
        <span class="nb">hex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">base_exp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">experiments</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
    <span class="n">full_fig</span><span class="o">.</span><span class="n">line</span><span class="p">(</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">base_exp</span><span class="o">.</span><span class="n">freq_col</span><span class="p">],</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">base_exp</span><span class="o">.</span><span class="n">int_col</span><span class="p">]</span> <span class="o">/</span> <span class="n">base_exp</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">baseline</span><span class="p">,</span>
        <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">legend</span><span class="o">=</span><span class="n">f</span><span class="s2">&quot;Ref; </span><span class="si">{base_exp.session.experiment}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="c1"># Loop over all the experiments and plot them up</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">experiment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">experiments</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">full_fig</span><span class="o">.</span><span class="n">line</span><span class="p">(</span>
                <span class="n">experiment</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">experiment</span><span class="o">.</span><span class="n">freq_col</span><span class="p">],</span>
                <span class="n">experiment</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">experiment</span><span class="o">.</span><span class="n">int_col</span><span class="p">]</span> <span class="o">/</span> <span class="n">experiment</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">baseline</span><span class="p">,</span>
                <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
                <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                <span class="n">legend</span><span class="o">=</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{experiment.session.experiment}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="c1"># Set some legend stuffs</span>
    <span class="n">full_fig</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">click_policy</span> <span class="o">=</span> <span class="s2">&quot;hide&quot;</span>
    <span class="n">full_fig</span><span class="o">.</span><span class="n">legend</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="s2">&quot;top_left&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;plot_height&quot;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
        <span class="s2">&quot;plot_width&quot;</span><span class="p">:</span> <span class="mi">900</span><span class="p">,</span>
        <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Unique Features&quot;</span>
    <span class="p">}</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">unique_fig</span> <span class="o">=</span> <span class="n">figurefactory</span><span class="o">.</span><span class="n">init_bokeh_figure</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">base</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">correlate_experiments</span><span class="p">(</span>
        <span class="n">experiments</span><span class="p">,</span> <span class="n">thres_prox</span><span class="o">=</span><span class="n">thres_prox</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span>
    <span class="p">)</span>
    <span class="n">unique_fig</span><span class="o">.</span><span class="n">line</span><span class="p">(</span>
        <span class="n">base</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">],</span>
        <span class="n">base</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Unique Spectrum&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">base</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">baseline</span><span class="p">,</span>
        <span class="n">line_width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">unique_fig</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">axis_label</span> <span class="o">=</span> <span class="s2">&quot;Signal-to-noise&quot;</span>
    <span class="n">combined_fig</span> <span class="o">=</span> <span class="n">layout</span><span class="p">([</span><span class="n">full_fig</span><span class="p">,</span> <span class="n">unique_fig</span><span class="p">],</span> <span class="n">sizing_mode</span><span class="o">=</span><span class="s2">&quot;stretch_both&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">filepath</span><span class="p">:</span>
        <span class="n">save</span><span class="p">(</span><span class="n">combined_fig</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;ExperimentComparison&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">combined_fig</span></div>


<div class="viewcode-block" id="copy_assignments"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.copy_assignments">[docs]</a><span class="k">def</span> <span class="nf">copy_assignments</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">corr_mat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to copy assignments from experiment B over to experiment A. The</span>
<span class="sd">    correlation matrix argument requires the output from the</span>
<span class="sd">    `correlate_experiments` function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A, B : AssignmentSession</span>
<span class="sd">        AssignmentSession objects, where the assignments from B are copied</span>
<span class="sd">        into A</span>
<span class="sd">    corr_mat : 2D array</span>
<span class="sd">        2D array mask with length A x B</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find actual correlations; should end up having two 1D arrays of equal</span>
    <span class="c1"># length</span>
    <span class="n">non_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">corr_mat</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Indexes of i and j correspond to A and B indexes</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">non_zero</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">non_zero</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">a_trans</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">line_lists</span><span class="p">[</span><span class="s2">&quot;Peaks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">b_trans</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">line_lists</span><span class="p">[</span><span class="s2">&quot;Peaks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">b_dict</span> <span class="o">=</span> <span class="n">b_trans</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">b_dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;frequency&quot;</span><span class="p">)</span>
        <span class="n">a_trans</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">b_dict</span><span class="p">)</span></div>


<div class="viewcode-block" id="correlate_experiments"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.correlate_experiments">[docs]</a><span class="k">def</span> <span class="nf">correlate_experiments</span><span class="p">(</span><span class="n">experiments</span><span class="p">,</span> <span class="n">thres_prox</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to find correlations between experiments, looking for common</span>
<span class="sd">    peaks detected in every provided experiment. This function uses by the first</span>
<span class="sd">    experiment as the base for comparison by default. Coincidences are searched</span>
<span class="sd">    for between this base and the other provided experiment, and ultimately combined</span>
<span class="sd">    to determine the common peaks.</span>

<span class="sd">    A copy of the base experiment is returned, along with a dictionary with</span>
<span class="sd">    frequencies of correlations between a given experiment and the base.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    experiments : tuple-like</span>
<span class="sd">        Iterable list/tuple of AssignmentSession objects.</span>
<span class="sd">    thres_prox : float, optional</span>
<span class="sd">        Proximity in frequency units for determining if peaks are the same.</span>
<span class="sd">        If thres-abs is False, this value is treated as a percentage of the</span>
<span class="sd">        center frequency.</span>
<span class="sd">    index : int, optional</span>
<span class="sd">        Index for the experiment to use as a base for comparisons.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    base_exp : AssignmentSession object</span>
<span class="sd">        A deep copy of the first experiment, with the updated spectra.</span>
<span class="sd">    return_dict : dict</span>
<span class="sd">        Dictionary where keys correspond to the experiment number and</span>
<span class="sd">        values are 1D arrays of frequencies that are coincident</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Use the a selected experiment as a base comparison</span>
    <span class="n">base_exp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">experiments</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
    <span class="n">base_freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">base_exp</span><span class="o">.</span><span class="n">line_lists</span><span class="p">[</span><span class="s2">&quot;Peaks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">frequencies</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">masks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">experiment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">experiments</span><span class="p">):</span>
        <span class="c1"># Ignore the base experiment</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">comp_freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">experiment</span><span class="o">.</span><span class="n">line_lists</span><span class="p">[</span><span class="s2">&quot;Peaks&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">frequencies</span>
                <span class="p">)</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">isin_array</span><span class="p">(</span><span class="n">base_freqs</span><span class="p">,</span> <span class="n">comp_freqs</span><span class="p">,</span> <span class="n">thres_prox</span><span class="p">)</span>
                <span class="c1"># Convert to boolean mask</span>
                <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">bool</span>
                <span class="c1"># Work out a correlation matrix to find indices where the two</span>
                <span class="c1"># arrays are matched</span>
                <span class="n">correlations</span> <span class="o">=</span> <span class="n">hot_match_arrays</span><span class="p">(</span>
                    <span class="n">base_freqs</span><span class="p">,</span>
                    <span class="n">comp_freqs</span><span class="p">,</span>
                    <span class="n">thres_prox</span>
                <span class="p">)</span>
                <span class="n">indices</span><span class="p">[</span><span class="n">experiment</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">experiment</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="n">correlations</span><span class="p">]</span>
                <span class="n">masks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Experiment </span><span class="si">{index}</span><span class="s2"> is missing peaks!&quot;</span><span class="p">)</span>
    <span class="c1"># Take the product column-wise, which gives only peaks which are common</span>
    <span class="c1"># to all experiments</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">all_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If there&#39;s only one comparison being made</span>
        <span class="n">all_index</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># Mask frequencies such that we are keeping on transitions that are common</span>
    <span class="c1"># across all experiments</span>
    <span class="n">uncommon_freqs</span> <span class="o">=</span> <span class="n">base_freqs</span><span class="p">[</span><span class="n">all_index</span><span class="p">]</span>
    <span class="n">common_freqs</span> <span class="o">=</span> <span class="n">base_freqs</span><span class="p">[</span><span class="o">~</span><span class="n">all_index</span><span class="p">]</span>
    <span class="c1"># Get spectra that show only coincidences and only unique peaks.</span>
    <span class="n">common_int</span> <span class="o">=</span> <span class="n">blank_spectrum</span><span class="p">(</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="n">common_freqs</span><span class="p">,</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">baseline</span><span class="p">,</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">noise_rms</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">freq_col</span><span class="p">,</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">int_col</span><span class="p">,</span>
        <span class="n">df</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">uncommon_int</span> <span class="o">=</span> <span class="n">blank_spectrum</span><span class="p">(</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">data</span><span class="p">,</span>
        <span class="n">uncommon_freqs</span><span class="p">,</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">baseline</span><span class="p">,</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">noise_rms</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">,</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">freq_col</span><span class="p">,</span>
        <span class="n">base_exp</span><span class="o">.</span><span class="n">int_col</span><span class="p">,</span>
        <span class="n">df</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="c1"># Set the new intensity columns</span>
    <span class="n">base_exp</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Coincidence Spectrum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">common_int</span>
    <span class="n">base_exp</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Unique Spectrum&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">uncommon_int</span>
    <span class="k">return</span> <span class="n">base_exp</span><span class="p">,</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="match_artifacts"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.match_artifacts">[docs]</a><span class="k">def</span> <span class="nf">match_artifacts</span><span class="p">(</span><span class="n">on_exp</span><span class="p">,</span> <span class="n">off_exp</span><span class="p">,</span> <span class="n">thres</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">freq_col</span><span class="o">=</span><span class="s2">&quot;Frequency&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to remove a set of artifacts found in a blank spectrum.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    on_exp - AssignmentSession object</span>
<span class="sd">        Experiment with the sample on; i.e. contains molecular features</span>
<span class="sd">    off_exp - AssignmentSession object</span>
<span class="sd">        Experiment with no sample; i.e. only artifacts</span>
<span class="sd">    thres - float, optional</span>
<span class="sd">        Threshold in absolute frequency units to match</span>
<span class="sd">    freq_col - str, optional</span>
<span class="sd">        Column specifying frequency in the pandas dataframes</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    candidates - dict</span>
<span class="sd">        Dictionary with keys corresponding to the uline index, and</span>
<span class="sd">        values the frequency</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check to make sure peaks are found</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">on_exp</span><span class="p">,</span> <span class="n">off_exp</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;peaks&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> has no peaks!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

    <span class="n">ufreqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">uline</span><span class="o">.</span><span class="n">frequency</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">uline</span> <span class="ow">in</span> <span class="n">on_exp</span><span class="o">.</span><span class="n">ulines</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">off_exp</span><span class="o">.</span><span class="n">peaks</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">min_freq</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">freq_col</span><span class="p">]</span> <span class="o">-</span> <span class="n">thres</span>
        <span class="n">max_freq</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">freq_col</span><span class="p">]</span> <span class="o">+</span> <span class="n">thres</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">routines</span><span class="o">.</span><span class="n">find_nearest</span><span class="p">(</span><span class="n">ufreqs</span><span class="p">,</span> <span class="n">row</span><span class="p">[</span><span class="n">freq_col</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">min_freq</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">max_freq</span><span class="p">:</span>
            <span class="n">candidates</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">candidates</span></div>


<div class="viewcode-block" id="line_weighting"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.line_weighting">[docs]</a><span class="k">def</span> <span class="nf">line_weighting</span><span class="p">(</span><span class="n">frequency</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">catalog_frequency</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">intensity</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function for calculating the line weighting associated with each assignment candidate. The formula is based on</span>
<span class="sd">    intensity and frequency offset, such as to favor strong lines that are spot on over weak lines that are further</span>
<span class="sd">    away.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequency: float</span>
<span class="sd">        Center frequency in MHz; typically the u-line frequency.</span>
<span class="sd">    catalog_frequency: float</span>
<span class="sd">        Catalog frequency of the candidate</span>
<span class="sd">    intensity: float, optional</span>
<span class="sd">        log Intensity of the transition; includes the line strength and the temperature factor.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    weighting: float</span>
<span class="sd">        Associated weight value. Requires normalization</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">frequency</span> <span class="o">-</span> <span class="n">catalog_frequency</span><span class="p">)</span>
    <span class="n">weighting</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reciprocal</span><span class="p">(</span><span class="n">deviation</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">intensity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weighting</span> <span class="o">*=</span> <span class="mf">10.</span><span class="o">**</span><span class="n">intensity</span>
    <span class="k">return</span> <span class="n">weighting</span></div>


<div class="viewcode-block" id="filter_spectrum"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.filter_spectrum">[docs]</a><span class="k">def</span> <span class="nf">filter_spectrum</span><span class="p">(</span><span class="n">intensity</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s2">&quot;hanning&quot;</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a specified window function to a signal. The window functions are</span>
<span class="sd">    taken from the `signal.windows` module of SciPy, so check what is available</span>
<span class="sd">    before throwing it into this function.</span>

<span class="sd">    The window function is convolved with the signal by taking the time-</span>
<span class="sd">    domain product, and doing the inverse FFT to get the convolved spectrum</span>
<span class="sd">    back.</span>

<span class="sd">    The one exception is the gaussian window - if a user specifies &quot;gaussian&quot;</span>
<span class="sd">    for the window function, the actual window function applied here is a</span>
<span class="sd">    half gaussian, i.e. a 1D gaussian blur.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataframe: pandas DataFrame</span>
<span class="sd">        Pandas dataframe containing the spectral information</span>
<span class="sd">    int_col: str, optional</span>
<span class="sd">        Column name to reference the signal</span>
<span class="sd">    window: str, optional</span>
<span class="sd">        Name of the window function as implemented in SciPy.</span>
<span class="sd">    sigma:</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_y: array_like</span>
<span class="sd">        Numpy 1D array containing the convolved signal</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">windows</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Specified window not available in SciPy.&quot;</span><span class="p">)</span>
    <span class="n">data_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">window</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data_length</span><span class="p">)</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">lineshapes</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">sigma</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">windows</span><span class="o">.</span><span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">data_length</span><span class="p">)</span>
    <span class="n">fft_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span>
    <span class="c1"># Convolve the signal with the window function</span>
    <span class="n">new_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span>
        <span class="n">window</span> <span class="o">*</span> <span class="n">fft_y</span>
    <span class="p">)</span>
    <span class="c1"># Return only the real part of the FFT</span>
    <span class="n">new_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_y</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_y</span></div>


<div class="viewcode-block" id="detect_artifacts"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.detect_artifacts">[docs]</a><span class="k">def</span> <span class="nf">detect_artifacts</span><span class="p">(</span><span class="n">frequencies</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">2e-3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Quick one-liner function to perform a very rudimentary test for</span>
<span class="sd">    RFI. This method relies on the assumption that any frequency that</span>
<span class="sd">    is suspiciously close to an exact number (e.g. 16250.0000) is very</span>
<span class="sd">    likely an artifact.</span>
<span class="sd">    </span>
<span class="sd">    The function will calculate the difference between each frequency</span>
<span class="sd">    and its nearest whole number, and return frequencies that are</span>
<span class="sd">    within a specified tolerance.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequencies : NumPy 1D array</span>
<span class="sd">        Array of frequencies to check for artifacts.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Maximum tolerance to be used to check whether frequency</span>
<span class="sd">        is close enough to its rounded value, by default 2e-3</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    NumPy 1D array</span>
<span class="sd">        Returns the frequencies that match the specified criteria.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span> <span class="o">-</span> <span class="n">frequencies</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span>
    <span class="k">return</span> <span class="n">frequencies</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span></div>


<div class="viewcode-block" id="cross_correlate"><a class="viewcode-back" href="../../../pyspectools.spectra.html#pyspectools.spectra.analysis.cross_correlate">[docs]</a><span class="nd">@numba</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cross_correlate</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">lags</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cross-correlate two arrays a and b that are of equal length by</span>
<span class="sd">    lagging b with respect to a. Uses np.roll to shift b by values</span>
<span class="sd">    of lag, and appropriately zeros out &quot;out of bounds&quot; values.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b: Length n NumPy 1D arrays</span>
<span class="sd">        Arrays containing the values to cross-correlate. Must be the</span>
<span class="sd">        same length.</span>
<span class="sd">    lags : [type], optional</span>
<span class="sd">        [description], by default None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">lags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">lags</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span>
    <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lags</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">lag</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">:</span>
        <span class="n">b_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lag</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">b_temp</span><span class="p">[</span><span class="n">b_temp</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">lag</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">lag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">b_temp</span><span class="p">[:</span><span class="n">lag</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">C</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b_temp</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="n">lags</span></div>
</pre></div>

        </div>
      </div>

      <div id="side-menu-container">

        <div id="search" role="search">
        <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
            <input type="text" name="q" placeholder="Search..." />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
        </form>
</div>

        <div id="side-menu" role="navigation">

          
  
    
  
  
    <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pyspectools.spectra.html"><cite>pyspectools.spectra</cite> Module</a></li>
</ul>

  


        </div>

        

      </div>

    </div>

<footer>
    <div id="footer-info">
        <ul id="build-details">
            

            

            
        </ul>
        <div id="credit">
            created with <a href="http://sphinx-doc.org/">Sphinx</a> and <a href="https://github.com/Autophagy/insegel">Insegel</a>

        </div>
    </div>

    <a id="menu-toggle" class="fa fa-bars" aria-hidden="true"></a>

    <script type="text/javascript">
      $("#menu-toggle").click(function() {
        $("#menu-toggle").toggleClass("toggled");
        $("#side-menu-container").slideToggle(300);
      });
    </script>

</footer> 

</div>

</body>
</html>
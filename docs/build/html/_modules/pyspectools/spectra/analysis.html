
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>pyspectools.spectra.analysis &#8212; PySpecTools 3.1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pyspectools.spectra.analysis</h1><div class="highlight"><pre>
<span></span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">chain</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">peakutils</span>
<span class="kn">from</span> <span class="nn">astroquery.splatalogue</span> <span class="k">import</span> <span class="n">Splatalogue</span>
<span class="kn">from</span> <span class="nn">astropy</span> <span class="k">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>
<span class="kn">from</span> <span class="nn">lmfit</span> <span class="k">import</span> <span class="n">models</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">savgol_filter</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="k">import</span> <span class="n">AffinityPropagation</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">silhouette_samples</span>

<span class="kn">from</span> <span class="nn">pyspectools.spectra</span> <span class="k">import</span> <span class="n">plotting</span>
<span class="kn">from</span> <span class="nn">pyspectools</span> <span class="k">import</span> <span class="n">fitting</span>


<div class="viewcode-block" id="fit_line_profile"><a class="viewcode-back" href="../../../index.html#pyspectools.spectra.analysis.fit_line_profile">[docs]</a><span class="k">def</span> <span class="nf">fit_line_profile</span><span class="p">(</span><span class="n">spec_df</span><span class="p">,</span> <span class="n">frequency</span><span class="p">,</span> <span class="n">intensity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Low level function wrapper to to fit line profiles</span>
<span class="sd">        in chirp spectra.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;Cleaned&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spec_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="n">spec_df</span><span class="p">[</span><span class="s2">&quot;Cleaned&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spec_df</span><span class="p">[</span><span class="s2">&quot;Intensity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">VoigtModel</span><span class="p">()</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">make_params</span><span class="p">()</span>
    <span class="c1"># Set up boundary conditions for the fit</span>
    <span class="n">params</span><span class="p">[</span><span class="s2">&quot;center&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
        <span class="n">frequency</span><span class="p">,</span>
        <span class="nb">min</span><span class="o">=</span><span class="n">frequency</span> <span class="o">-</span> <span class="mf">0.03</span><span class="p">,</span>
        <span class="nb">max</span><span class="o">=</span><span class="n">frequency</span> <span class="o">+</span> <span class="mf">0.03</span>
    <span class="p">)</span>
    <span class="c1"># If an intensity is supplied</span>
    <span class="k">if</span> <span class="n">intensity</span><span class="p">:</span>
        <span class="n">params</span><span class="p">[</span><span class="s2">&quot;amplitude&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span>
    <span class="n">params</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
        <span class="mf">0.05</span><span class="p">,</span>
        <span class="nb">min</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span>
        <span class="nb">max</span><span class="o">=</span><span class="mf">0.07</span>
    <span class="p">)</span>
    <span class="n">freq_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">frequency</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">]]</span>
    <span class="n">slice_df</span> <span class="o">=</span> <span class="n">spec_df</span><span class="p">[</span>
        <span class="p">(</span><span class="n">spec_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">freq_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">spec_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">freq_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">]</span>
    <span class="c1"># Fit the peak lineshape</span>
    <span class="n">fit_results</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
        <span class="n">slice_df</span><span class="p">[</span><span class="s2">&quot;Intensity&quot;</span><span class="p">],</span>
        <span class="n">params</span><span class="p">,</span>
        <span class="n">x</span><span class="o">=</span><span class="n">slice_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">fit_results</span><span class="o">.</span><span class="n">fit_report</span><span class="p">())</span>
    <span class="n">yfit</span> <span class="o">=</span> <span class="n">fit_results</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">spec_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">spec_df</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">yfit</span>
    <span class="c1"># Subtract the peak contribution</span>
    <span class="n">spec_df</span><span class="p">[</span><span class="s2">&quot;Cleaned&quot;</span><span class="p">]</span> <span class="o">-=</span> <span class="n">yfit</span>
    <span class="k">return</span> <span class="n">fit_results</span></div>


<div class="viewcode-block" id="peak_find"><a class="viewcode-back" href="../../../index.html#pyspectools.spectra.analysis.peak_find">[docs]</a><span class="k">def</span> <span class="nf">peak_find</span><span class="p">(</span><span class="n">spec_df</span><span class="p">,</span> <span class="n">freq_col</span><span class="o">=</span><span class="s2">&quot;Frequency&quot;</span><span class="p">,</span> <span class="n">int_col</span><span class="o">=</span><span class="s2">&quot;Intensity&quot;</span><span class="p">,</span> <span class="n">thres</span><span class="o">=</span><span class="mf">0.015</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        Wrapper for peakutils applied to pandas dataframes. First finds</span>
<span class="sd">        the peak indices, which are then used to fit Gaussians to determine</span>
<span class="sd">        the center frequency for each peak.</span>

<span class="sd">        parameters:</span>
<span class="sd">        ---------------</span>
<span class="sd">        spec_df - dataframe containing the spectrum</span>
<span class="sd">        freq_col - str denoting frequency column</span>
<span class="sd">        int_col - str denoting intensity column</span>
<span class="sd">        thres - threshold for peak detection</span>

<span class="sd">        returns:</span>
<span class="sd">        ---------------</span>
<span class="sd">        peak_df - pandas dataframe containing the peaks frequency/intensity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">peak_indices</span> <span class="o">=</span> <span class="n">peakutils</span><span class="o">.</span><span class="n">indexes</span><span class="p">(</span>
        <span class="n">spec_df</span><span class="p">[</span><span class="n">int_col</span><span class="p">],</span>
        <span class="n">thres</span><span class="o">=</span><span class="n">thres</span><span class="p">,</span>
        <span class="n">min_dist</span><span class="o">=</span><span class="mi">10</span>
        <span class="p">)</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">peakutils</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="n">spec_df</span><span class="p">[</span><span class="n">freq_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">y</span><span class="o">=</span><span class="n">spec_df</span><span class="p">[</span><span class="n">int_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="n">ind</span><span class="o">=</span><span class="n">peak_indices</span><span class="p">,</span>
        <span class="n">width</span><span class="o">=</span><span class="mi">20</span>
        <span class="p">)</span>
    <span class="c1"># Get the peaks if we were just using indexes</span>
    <span class="n">direct_df</span> <span class="o">=</span> <span class="n">spec_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">peak_indices</span><span class="p">]</span>
    <span class="n">direct_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Calculate the difference in fit vs. approximate peak</span>
    <span class="c1"># frequencies</span>
    <span class="n">differences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">direct_df</span><span class="p">[</span><span class="n">freq_col</span><span class="p">]</span> <span class="o">-</span> <span class="n">frequencies</span><span class="p">)</span>
    <span class="n">intensities</span> <span class="o">=</span> <span class="n">spec_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">peak_indices</span><span class="p">][</span><span class="n">int_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">peak_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">intensities</span><span class="p">)),</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">,</span> <span class="s2">&quot;Intensity&quot;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="c1"># Take the indexed frequencies if the fit exploded</span>
    <span class="c1"># and deviates significantly from the original prediction</span>
    <span class="n">peak_df</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
        <span class="n">direct_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">differences</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">peak_df</span></div>


<div class="viewcode-block" id="search_center_frequency"><a class="viewcode-back" href="../../../index.html#pyspectools.spectra.analysis.search_center_frequency">[docs]</a><span class="k">def</span> <span class="nf">search_center_frequency</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Wrapper for the astroquery Splatalogue search</span>
<span class="sd">        This function will take a center frequency, and query splatalogue</span>
<span class="sd">        within the CDMS and JPL linelists for carriers of the line.</span>

<span class="sd">        Input arguments:</span>
<span class="sd">        frequency - float specifying the center frequency</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_freq</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">-</span> <span class="n">width</span>
    <span class="n">max_freq</span> <span class="o">=</span> <span class="n">frequency</span> <span class="o">+</span> <span class="n">width</span>
    <span class="n">splat_df</span> <span class="o">=</span> <span class="n">Splatalogue</span><span class="o">.</span><span class="n">query_lines</span><span class="p">(</span>
        <span class="n">min_freq</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">MHz</span><span class="p">,</span>
        <span class="n">max_freq</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">MHz</span><span class="p">,</span>
        <span class="n">line_lists</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CDMS&quot;</span><span class="p">,</span> <span class="s2">&quot;JPL&quot;</span><span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
    <span class="c1"># These are the columns wanted</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;Species&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Chemical Name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Meas Freq-GHz(rest frame,redshifted)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Freq-GHz(rest frame,redshifted)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Resolved QNs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CDMS/JPL Intensity&quot;</span><span class="p">,</span>
        <span class="s2">&quot;E_U (K)&quot;</span>
        <span class="p">]</span>
    <span class="c1"># Take only what we want</span>
    <span class="n">splat_df</span> <span class="o">=</span> <span class="n">splat_df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span>
    <span class="n">splat_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;Species&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Chemical Name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Meas Freq-GHz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Freq-GHz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Resolved QNs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;CDMS/JPL Intensity&quot;</span><span class="p">,</span>
        <span class="s2">&quot;E_U (K)&quot;</span>
        <span class="p">]</span>
    <span class="c1"># Now we combine the frequency measurements</span>
    <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Meas Freq-GHz&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="c1"># Replace missing experimental data with calculated</span>
    <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Freq-GHz&quot;</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Convert to MHz</span>
    <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Frequency&quot;</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1000.</span>
    <span class="k">return</span> <span class="n">splat_df</span></div>


<div class="viewcode-block" id="assign_peaks"><a class="viewcode-back" href="../../../index.html#pyspectools.spectra.analysis.assign_peaks">[docs]</a><span class="k">def</span> <span class="nf">assign_peaks</span><span class="p">(</span><span class="n">spec_df</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Higher level function that will help assign features</span>
<span class="sd">        in a chirp spectrum.</span>

<span class="sd">        Input arguments:</span>
<span class="sd">        spec_df - pandas dataframe containing chirp data</span>
<span class="sd">        frequencies - iterable containing center frequencies of peaks</span>
<span class="sd">        Optional arguments are passed into the peak detection as well</span>
<span class="sd">        as in the plotting functions.</span>

<span class="sd">        Returns a dataframe containing all the assignments, and a list</span>
<span class="sd">        of unidentified peak frequencies.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unassigned</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">dataframes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="n">frequencies</span><span class="p">:</span>
        <span class="n">splat_df</span> <span class="o">=</span> <span class="n">search_center_frequency</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
        <span class="n">nitems</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">splat_df</span><span class="p">)</span>
        <span class="c1"># Only act if there&#39;s something found</span>
        <span class="k">if</span> <span class="n">nitems</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Deviation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="n">splat_df</span><span class="p">[</span><span class="s2">&quot;Combined&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">frequency</span>
                    <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">splat_df</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Peak frequency is &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">frequency</span><span class="p">))</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="nb">input</span><span class="p">(</span>
                        <span class="s2">&quot;Please choose an assignment index: 0-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nitems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">assigned</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deferring assignment&quot;</span><span class="p">)</span>
                <span class="n">unassigned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
                <span class="n">assigned</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Take the assignment. Double brackets because otherwise</span>
            <span class="c1"># a series is returned rather than a dataframe</span>
            <span class="k">if</span> <span class="n">assigned</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">assignment</span> <span class="o">=</span> <span class="n">splat_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">index</span><span class="p">]]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span>
                    <span class="p">[</span><span class="s2">&quot;Deviation&quot;</span><span class="p">],</span>
                    <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
                <span class="n">ass_freq</span> <span class="o">=</span> <span class="n">assignment</span><span class="p">[</span><span class="s2">&quot;Combined&quot;</span><span class="p">]</span>
                <span class="c1"># If the measurement is not available, go for</span>
                <span class="c1"># the predicted value</span>
                <span class="n">ass_name</span> <span class="o">=</span> <span class="n">assignment</span><span class="p">[</span><span class="s2">&quot;Species&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">assignment</span><span class="p">[</span><span class="s2">&quot;Resolved QNs&quot;</span><span class="p">]</span>
                <span class="c1"># Clean the line</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">fit_line_profile</span><span class="p">(</span><span class="n">spec_df</span><span class="p">,</span> <span class="n">frequency</span><span class="p">)</span>
                <span class="c1"># Keep track of the assignments in a dataframe</span>
                <span class="n">dataframes</span> <span class="o">=</span> <span class="n">dataframes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">assignment</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;----------------------------------------------------&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No species known for &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">frequency</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dataframes</span><span class="p">,</span> <span class="n">unassigned</span></div>


<div class="viewcode-block" id="brute_harmonic_search"><a class="viewcode-back" href="../../../index.html#pyspectools.spectra.analysis.brute_harmonic_search">[docs]</a><span class="k">def</span> <span class="nf">brute_harmonic_search</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">maxJ</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dev_thres</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">prefilter</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that will search for possible harmonic candidates</span>
<span class="sd">        in a list of frequencies. Wraps the lower level function.</span>

<span class="sd">        Generates every possible 4 membered combination of the</span>
<span class="sd">        frequencies, and makes a first pass filtering out unreasonable</span>
<span class="sd">        combinations.</span>

<span class="sd">        parameters:</span>
<span class="sd">        ----------------</span>
<span class="sd">        frequencies - iterable containing floats of frequencies (ulines)</span>
<span class="sd">        maxJ - maximum value of J considered for quantum numbers</span>
<span class="sd">        dev_thres - standard deviation threshold for filtering unlikely</span>
<span class="sd">                    combinations of frequencies</span>
<span class="sd">        prefilter - bool dictating whether or not the frequency lists</span>
<span class="sd">                    are prescreened by standard deviation. This potentially</span>
<span class="sd">                    biases away from missing transitions!</span>

<span class="sd">        returns:</span>
<span class="sd">        ----------------</span>
<span class="sd">        results_df - pandas dataframe containing RMS information and fitted</span>
<span class="sd">                     constants</span>
<span class="sd">        fit_results - list containing all of ModelResult objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
    <span class="c1"># List for holding candidates</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Generating possible frequency combinations.&quot;</span><span class="p">)</span>
    <span class="c1"># Sweep through all possible combinations, and look</span>
    <span class="c1"># for viable candidates</span>
    <span class="k">if</span> <span class="n">prefilter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]:</span>
            <span class="c1"># Check the length of array we need...</span>
            <span class="c1">#if comb(len(frequencies), length) &gt; 5e6:</span>
            <span class="c1">#    pass</span>
            <span class="n">combos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">combinations</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">length</span><span class="p">)))</span>
            <span class="c1"># Calculate the standard deviation between frequency</span>
            <span class="c1"># entries - if the series is harmonic, then the deviation</span>
            <span class="c1"># should be low and only due to CD terms</span>
            <span class="n">deviation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">combos</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">combos</span> <span class="o">=</span> <span class="n">combos</span><span class="p">[</span><span class="n">deviation</span> <span class="o">&lt;</span> <span class="mf">100.</span><span class="p">]</span>
            <span class="n">deviation</span> <span class="o">=</span> <span class="n">deviation</span><span class="p">[</span><span class="n">deviation</span> <span class="o">&lt;</span> <span class="mf">100.</span><span class="p">]</span>
            <span class="n">sorted_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">deviation</span><span class="p">)[:</span><span class="mi">50</span><span class="p">]</span>
            <span class="n">sorted_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">deviation</span><span class="p">)[:</span><span class="mi">50</span><span class="p">]</span>
            <span class="n">candidates</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">combos</span><span class="p">[</span><span class="n">sorted_indexes</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of candidates: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">prefilter</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># If we won&#39;t prefilter, then just chain the</span>
        <span class="c1"># generators together</span>
        <span class="c1"># THIS WILL BE FREAKING SLOW</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span>
            <span class="n">combinations</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">combinations</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
            <span class="n">combinations</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">data_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">fit_results</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">prefilter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.50</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">])</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="n">progress</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
        <span class="n">progress</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">prog</span><span class="p">)</span> <span class="k">for</span> <span class="n">prog</span> <span class="ow">in</span> <span class="n">progress</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Looping over candidate combinations&quot;</span><span class="p">)</span>
    <span class="c1"># Perform the fitting procedure on candidate combinations</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">candidates</span><span class="p">):</span>
        <span class="c1"># Only fit the ones that </span>
        <span class="n">min_rms</span><span class="p">,</span> <span class="n">min_index</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">fit_values</span><span class="p">,</span> <span class="n">fit_objs</span> <span class="o">=</span> <span class="n">fitting</span><span class="o">.</span><span class="n">harmonic_fit</span><span class="p">(</span>
            <span class="n">candidate</span><span class="p">,</span> 
            <span class="n">maxJ</span><span class="o">=</span><span class="n">maxJ</span><span class="p">,</span> 
            <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="n">data_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[</span><span class="n">index</span><span class="p">,</span> 
             <span class="n">min_rms</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="p">),</span> 
             <span class="n">candidate</span><span class="p">,</span>
             <span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">fit_values</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>
            <span class="p">)</span>
        <span class="n">fit_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_objs</span><span class="p">[</span><span class="n">min_index</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">prefilter</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">progress</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> candidates screened.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finalizing results.&quot;</span><span class="p">)</span>
    <span class="n">results_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">data_list</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="s2">&quot;RMS&quot;</span><span class="p">,</span> <span class="s2">&quot;Frequencies&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="n">results_df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">([</span><span class="s2">&quot;RMS&quot;</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">results_df</span><span class="p">,</span> <span class="n">fit_results</span></div>


<div class="viewcode-block" id="harmonic_finder"><a class="viewcode-back" href="../../../index.html#pyspectools.spectra.analysis.harmonic_finder">[docs]</a><span class="k">def</span> <span class="nf">harmonic_finder</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">low_B</span><span class="o">=</span><span class="mf">400.</span><span class="p">,</span> <span class="n">high_B</span><span class="o">=</span><span class="mf">9000.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that will generate candidates for progressions.</span>
<span class="sd">        Every possible pair combination of frequencies are</span>
<span class="sd">        looped over, consider whether or not the B value is either</span>
<span class="sd">        too small (like C60 large) or too large (you won&#39;t have</span>
<span class="sd">        enough lines to make a progression), and search the</span>
<span class="sd">        frequencies to find the nearest candidates based on a</span>
<span class="sd">        prediction.</span>
<span class="sd">        </span>
<span class="sd">        parameters:</span>
<span class="sd">        ----------------</span>
<span class="sd">        frequencies - array or tuple-like containing the progressions</span>
<span class="sd">                      we expect to find</span>
<span class="sd">        search - optional argument threshold for determining if something</span>
<span class="sd">                 is close enough</span>
<span class="sd">                 </span>
<span class="sd">        returns:</span>
<span class="sd">        ----------------</span>
<span class="sd">        progressions - list of arrays corresponding to candidate progressions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)</span>
    <span class="n">progressions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="c1"># Ignore everything that is too large or</span>
        <span class="c1"># too small</span>
        <span class="n">guess_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">low_B</span> <span class="o">&lt;=</span> <span class="n">guess_B</span> <span class="o">&lt;=</span> <span class="n">high_B</span><span class="p">:</span>
            <span class="n">combo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span>
            <span class="c1"># From B, determine the next series of lines and</span>
            <span class="c1"># find the closest ones</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="n">find_series</span><span class="p">(</span><span class="n">combo</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">search</span><span class="p">)</span>          
            <span class="n">progressions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">progressions</span></div>


<div class="viewcode-block" id="cluster_AP_analysis"><a class="viewcode-back" href="../../../index.html#pyspectools.spectra.analysis.cluster_AP_analysis">[docs]</a><span class="k">def</span> <span class="nf">cluster_AP_analysis</span><span class="p">(</span><span class="n">progression_df</span><span class="p">,</span> <span class="n">sil_calc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">refit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper for the AffinityPropagation cluster method from</span>
<span class="sd">        scikit-learn.</span>

<span class="sd">        The dataframe provided will also receive new columns: Cluster index,</span>
<span class="sd">        and Silhouette. The latter corresponds to how likely a sample is</span>
<span class="sd">        sandwiched between clusters (0), how squarely it belongs in the</span>
<span class="sd">        assigned cluster (+1), or does not belong (-1). The cluster index</span>
<span class="sd">        corresponds to which cluster the sample belongs to.</span>

<span class="sd">        parameters:</span>
<span class="sd">        ---------------</span>
<span class="sd">        progression_df - pandas dataframe taken from the result of progression</span>
<span class="sd">                         fits</span>
<span class="sd">        sil_calc - bool indicating whether silhouettes are calculated</span>
<span class="sd">                   after the AP model is fit</span>
<span class="sd">        </span>
<span class="sd">        returns:</span>
<span class="sd">        --------------</span>
<span class="sd">        data - dict containing clustered frequencies and associated fits</span>
<span class="sd">        ap_obj - AffinityPropagation object containing all the information</span>
<span class="sd">                 as attributes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ap_options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">ap_options</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ap_options</span><span class="p">)</span>
    <span class="n">ap_obj</span> <span class="o">=</span> <span class="n">AffinityPropagation</span><span class="p">(</span><span class="o">**</span><span class="n">ap_options</span><span class="p">)</span>
    <span class="c1"># Determine clusters based on the RMS, B, and D</span>
    <span class="c1"># similarities</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fitting the Affinity Propagation model.&quot;</span><span class="p">)</span>
    <span class="n">ap_obj</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">progression_df</span><span class="p">[[</span><span class="s2">&quot;RMS&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Fit complete.&quot;</span><span class="p">)</span>
    <span class="n">progression_df</span><span class="p">[</span><span class="s2">&quot;Cluster indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ap_obj</span><span class="o">.</span><span class="n">labels_</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Determined </span><span class="si">{}</span><span class="s2"> clusters.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ap_obj</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">)))</span>
    <span class="c1"># Calculate the metric for determining how well a sample</span>
    <span class="c1"># fits into its cluster</span>
    <span class="k">if</span> <span class="n">sil_calc</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculating silhouettes.&quot;</span><span class="p">)</span>
        <span class="n">progression_df</span><span class="p">[</span><span class="s2">&quot;Silhouette&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">silhouette_samples</span><span class="p">(</span>
            <span class="n">progression_df</span><span class="p">[[</span><span class="s2">&quot;RMS&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">]],</span>
            <span class="n">progression_df</span><span class="p">[</span><span class="s2">&quot;Cluster indices&quot;</span><span class="p">],</span>
            <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span>
            <span class="p">)</span>
    
    <span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Aggregating results.&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">progression_df</span><span class="p">[</span><span class="s2">&quot;Cluster indices&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()):</span>
        <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">cluster_data</span> <span class="o">=</span> <span class="n">ap_obj</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="n">slice_df</span> <span class="o">=</span> <span class="n">progression_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">progression_df</span><span class="p">[</span><span class="s2">&quot;Cluster indices&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">label</span><span class="p">]</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">progression_df</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="n">unique_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">slice_df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">unique_frequencies</span> <span class="o">=</span> <span class="n">unique_frequencies</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">unique_frequencies</span><span class="p">)]</span>
        <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;Frequencies&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unique_frequencies</span>
        <span class="k">if</span> <span class="n">refit</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># Refit the whole list of frequencies with B and D again</span>
            <span class="n">BJ_model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">fitting</span><span class="o">.</span><span class="n">calc_harmonic_transition</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">BJ_model</span><span class="o">.</span><span class="n">make_params</span><span class="p">()</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;B&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                <span class="n">cluster_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="nb">min</span><span class="o">=</span><span class="n">cluster_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">0.99</span><span class="p">,</span>
                <span class="nb">max</span><span class="o">=</span><span class="n">cluster_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">1.01</span>
                <span class="p">)</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;D&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cluster_data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Get values of J based on B again</span>
            <span class="n">J</span> <span class="o">=</span> <span class="p">(</span><span class="n">unique_frequencies</span> <span class="o">/</span> <span class="n">cluster_data</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">fit</span> <span class="o">=</span> <span class="n">BJ_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">unique_frequencies</span><span class="p">,</span>
                <span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">params</span>
            <span class="p">)</span>
            <span class="c1"># Package results together</span>
            <span class="n">fit_values</span> <span class="o">=</span> <span class="n">fit</span><span class="o">.</span><span class="n">best_values</span>
            <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">best_values</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;oldRMS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s2">&quot;RMS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">residual</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Reuse old RMS</span>
            <span class="n">fit_values</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="n">cluster_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="n">cluster_data</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="s2">&quot;RMS&quot;</span><span class="p">:</span> <span class="n">cluster_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="p">}</span>
            <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fit_values</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">ap_obj</span></div>


<div class="viewcode-block" id="find_series"><a class="viewcode-back" href="../../../index.html#pyspectools.spectra.analysis.find_series">[docs]</a><span class="k">def</span> <span class="nf">find_series</span><span class="p">(</span><span class="n">combo</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">search</span><span class="o">=</span><span class="mf">0.005</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function that will exhaustively search for candidate</span>
<span class="sd">        progressions based on a pair of frequencies.</span>
<span class="sd">        </span>
<span class="sd">        The difference of the pair is used to estimate B,</span>
<span class="sd">        which is then used to calculate J. These values of</span>
<span class="sd">        J are then used to predict the next set of lines,</span>
<span class="sd">        which are searched for in the soup of frequencies.</span>
<span class="sd">        The closest matches are added to a list which is returned.</span>

<span class="sd">        This is done so that even if frequencies are missing</span>
<span class="sd">        a series of lines can still be considered.</span>

<span class="sd">        parameters:</span>
<span class="sd">        ---------------</span>
<span class="sd">        combo - pair of frequencies corresponding to initial guess</span>
<span class="sd">        frequencies - array of frequencies to be searched</span>
<span class="sd">        search - optional threshold for determining the search range</span>
<span class="sd">                 to look for candidates</span>

<span class="sd">        returns:</span>
<span class="sd">        --------------</span>
<span class="sd">        array of candidate frequencies</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lowest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span>
    <span class="n">approx_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">combo</span><span class="p">))</span>
    <span class="n">minJ</span> <span class="o">=</span> <span class="p">(</span><span class="n">lowest</span> <span class="o">/</span> <span class="n">approx_B</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">minJ</span><span class="p">,</span> <span class="n">minJ</span> <span class="o">+</span> <span class="mf">20.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="c1"># Guess where all the next frequencies are</span>
    <span class="n">guess_centers</span> <span class="o">=</span> <span class="n">J</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">approx_B</span>
    <span class="c1"># Make sure it&#39;s within the band of trial frequencies</span>
    <span class="n">guess_centers</span> <span class="o">=</span> <span class="n">guess_centers</span><span class="p">[</span><span class="n">guess_centers</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)]</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">guess</span> <span class="ow">in</span> <span class="n">guess_centers</span><span class="p">:</span>
        <span class="n">lower_guess</span> <span class="o">=</span> <span class="n">guess</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">search</span><span class="p">)</span>
        <span class="n">upper_guess</span> <span class="o">=</span> <span class="n">guess</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">search</span><span class="p">)</span>
        <span class="n">nearest_neighbours</span> <span class="o">=</span> <span class="n">frequencies</span><span class="p">[(</span><span class="n">frequencies</span> <span class="o">&gt;=</span> <span class="n">lower_guess</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">frequencies</span> <span class="o">&lt;=</span> <span class="n">upper_guess</span><span class="p">)]</span>
        <span class="c1"># If we don&#39;t find anything close enough, don&#39;t worry about it</span>
        <span class="c1"># this will make sure that missing lines aren&#39;t necessarily ignored</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nearest_neighbours</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Return the closest value to the predicted center</span>
            <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nearest_neighbours</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">guess</span> <span class="o">-</span> <span class="n">nearest_neighbours</span><span class="p">))])</span>
    <span class="k">return</span> <span class="n">candidates</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">PySpecTools</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Kelvin Lee.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>